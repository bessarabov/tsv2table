#!/usr/bin/perl

use strict;
use warnings FATAL => 'all';
use feature qw(say);
use utf8;
use open qw(:std :utf8);

use Getopt::Long;

sub parse_options {

    my $header;
    my $separator = "\t";
    my $help;

    GetOptions (
        'header=s' => \$header,
        'separator=s' => \$separator,
        'help' => \$help,
    ) or die("Error in command line arguments\n");

    if ($help) {

        say "
cat file.tsv | tsv2table [options]

Converts tsv data into a human-readable table.

Options:
    --header=<auto|on|off>   Specify if there is a header row in the input file.
                             Optional. Default is \"auto\"
    --separator=<value>      Specify the separator character.
                             Optional. Default is \"\\t\"

    --help                   Display this help message.

https://github.com/bessarabov/tsv2table
";

        exit 0;
    }

    if (defined($header)) {
        my %valid_header_values = (
            auto => 1,
            on => 1,
            off => 1,
        );
        if (!exists $valid_header_values{$header}) {
            say "Invalid value for --header=$header Valid values are: auto (default), on, off";
            exit 1;
        }
    } else {
        $header = 'auto';
    }

    if ($separator eq '\t') {
        $separator = "\t";
    }

    my $options = {
        header => $header,
        separator => $separator,
    };

}

sub get_type {
    my ($value) = @_;

    if ($value =~ /^-?\d+\z/a) {
        return 'int';
    } elsif ($value =~ /^-?\d+\.\d+\z/a) {
        return 'float';
    } else {
        return 'string';
    }
}

sub main {

    my $options = parse_options();

    my @data;

    my @max_column_length;
    my $row_number = 1;
    my %row_types;

    while (<>) {
        s/\r?\n\z//;
        my @row = split $options->{separator}, $_, -1;

        for (my $i = 0; $i < scalar @row; $i++) {
            if (length($row[$i]) >= ($max_column_length[$i] // 0)) {
                $max_column_length[$i] = length($row[$i]);
            }
            if ($row_number < 3) {
                my $type = get_type($row[$i]);
                $row_types{$row_number}->{$type} = 1;
            }
        }

        push @data, \@row;
        $row_number++;
    }

    my $header_printed = 0;
    my $data_has_header = 0;

    if (
        exists($row_types{2})
        && join('', sort keys %{$row_types{1}}) eq 'string'
        && join('', sort keys %{$row_types{2}}) ne 'string'
    ) {
        $data_has_header = 1
    }

    foreach my $row (@data) {
        my $count = scalar @$row;
        my $i = 0;
        foreach my $el (@$row) {
            my $align;

            if (get_type($el) eq 'int') {
                # align to the right
                $align = '';
            } else {
                # align to the left
                $align = '-';
            }

            printf "%$align" . $max_column_length[$i] .'s', $el;
            if ($count != $i+1) {
                print ' | ';
            }
            $i++;
        }
        print "\n";

        if (
            !$header_printed
            && (
                ($options->{header} eq 'on')
                || ($options->{header} eq 'auto' && $data_has_header)
            )
        ) {
            my $full_length = 0;
            $full_length += $_ foreach @max_column_length;
            say '-' x ($full_length + 3*(scalar(@max_column_length)-1));
            $header_printed = 1;
        }
    }

}
main() if not defined caller;
1;
