#!/usr/bin/perl

use strict;
use warnings FATAL => 'all';
use feature qw(say);
use utf8;
use open qw(:std :utf8);

use Getopt::Long;

sub parse_options {

    my $header;
    my $separator;
    my $help;

    GetOptions (
        'header=s' => \$header,
        'separator=s' => \$separator,
        'help' => \$help,
    ) or die("Error in command line arguments\n");

    if ($help) {

        say '
cat file.tsv | tsv2table [options]

Converts tsv data into a human-readable table.

Options:
    --header=<auto|on|off>   Specify if there is a header row in the input file.
                             Optional. Default is "auto"
    --separator=<value>      Specify the separator character.
                             Optional. Default is "\t"

    --help                   Display this help message.

https://github.com/bessarabov/tsv2table
';

        exit 0;
    }

    if (defined($header)) {
        my %valid_header_values = map { $_ => 1 } qw(
            auto
            on
            off
        );
        if (!exists $valid_header_values{$header}) {
            say "Invalid value for --header=$header Valid values are: auto (default), on, off";
            exit 1;
        }
    } else {
        $header = 'auto';
    }

    if (defined($separator)) {
        if ($separator eq '\t') {
            $separator = "\t";
        }
    } else {
        $separator = "\t";
    }

    my $options = {
        header => $header,
        separator => $separator,
    };

}

# my ($type, $non_fractional_length, $fractional_length)  = get_type('13.123'); # ('float', 2, 4)
sub get_type {
    my ($value) = @_;

    if ($value =~ /^-?\d+\z/a) {
        return 'int', length($value), 0;
    } elsif ($value =~ /^(-?\d+)(\.\d+)\z/a) {
        return 'float', length($1), length($2);
    } else {
        return 'string', length($value), 0;
    }
}

sub get_value_with_indentation {
    my ($value, $column_length, $global_fractional_length) = @_;

    my $align;
    my $additon_after_value = '';

    my ($type, $non_fractional_length, $fractional_length)  = get_type($value);

    if ($type eq 'int') {
        # align to the right
        $align = '';
        $additon_after_value = ' 'x$global_fractional_length;
    } elsif ($type eq 'float') {
        # align to the right
        $align = '';
        $additon_after_value = ' 'x($global_fractional_length - $fractional_length);
    } else {
        # align to the left
        $align = '-';
    }

    return sprintf "%$align" . $column_length .'s', $value . $additon_after_value;
}

sub main {

    my $options = parse_options();

    my @data;

    my @max_non_fractional_length;
    my @max_fractional_length;
    my $row_number = 1;
    my %row_types;

    while (<>) {
        s/\r?\n\z//;
        my @row = split($options->{separator}, $_, -1);

        for (my $i = 0; $i < scalar(@row); $i++) {
            my ($type, $non_fractional_length, $fractional_length)  = get_type($row[$i]);

            if ($non_fractional_length >= ($max_non_fractional_length[$i] // 0)) {
                $max_non_fractional_length[$i] = $non_fractional_length;
            }

            if ($fractional_length >= ($max_fractional_length[$i] // 0)) {
                $max_fractional_length[$i] = $fractional_length;
            }

            if ($row_number < 3) {
                $row_types{$row_number}->{$type} = 1;
            }
        }

        push @data, \@row;
        $row_number++;
    }

    my $header_printed = 0;
    my $data_has_header_heuristic = 0;

    if (
        exists($row_types{2})
        && join('', sort keys %{$row_types{1}}) eq 'string'
        && join('', sort keys %{$row_types{2}}) ne 'string'
    ) {
        $data_has_header_heuristic = 1
    }

    foreach my $row (@data) {
        my $count = scalar @$row;
        my $i = 0;
        foreach my $el (@$row) {
            print get_value_with_indentation($el, $max_non_fractional_length[$i] + $max_fractional_length[$i], $max_fractional_length[$i]);
            if ($count != $i+1) {
                print ' | ';
            }
            $i++;
        }
        print "\n";

        if (
            !$header_printed
            && (
                ($options->{header} eq 'on')
                || ($options->{header} eq 'auto' && $data_has_header_heuristic)
            )
        ) {
            my $full_length = 0;
            for (my $i = 0; $i < @max_non_fractional_length; $i++) {
                $full_length += $max_non_fractional_length[$i];
                $full_length += $max_fractional_length[$i];
            }
            say '-' x ($full_length + 3*(scalar(@max_non_fractional_length)-1));
            $header_printed = 1;
        }
    }

}
main() if not defined caller;
1;
